package deadsimpledb

import (
	"bytes"
	"fmt"
	"io"
	"math"
	"slices"
	"testing"
	"text/template"

	testAssert "github.com/stretchr/testify/assert"
)

func newLeafNodeFromMap(kv map[string]string) BtreeNode {
	sortedKeys := make([]string, 0, len(kv))
	for k := range kv {
		sortedKeys = append(sortedKeys, k)
	}
	slices.Sort(sortedKeys)
	node := newBtreeNode()
	node.setHeader(BTREE_LEAF_NODE, uint16(len(kv)))
	for i, k := range sortedKeys {
		nodeWriteAt(node, uint16(i), 0, []byte(k), []byte(kv[k]))
	}
	return node
}

func sliceFillWith(size uint, fill []byte) []byte {
	s := make([]byte, size)
	for i := 0; i < len(s); i += len(fill) {
		copy(s[i:], fill)
	}
	return s
}

type buildLeafNodeOption struct {
	size    uint   // The size of the node in bytes
	keyByte []byte // The byte used to fill each key
	kvProp  []uint
}

func truncate(s string, n int) string {
	var suffix string
	if len(s) > n {
		suffix = "..."
	}
	return s[:int(math.Min(float64(len(s)), float64(n)))] + suffix
}

// buildLeafNode creates a leaf node of the specified size in bytes.
// Each key is a single byte from key, and len(key) determines the number of KV pairs.
// kvProp defines the relative sizes of values, distributing available space proportionally.
// The value for each key is generated by repeating the key byte to fill its allocated size.
func buildLeafNode(size uint, key []byte, kvProp []uint) BtreeNode {
	// check that kvProp adds up to nKeys
	assert(len(kvProp) == len(key), "kvProp and key must have the same length")

	nKeys := len(key)
	ptrSize := BTREE_POINTER_SIZE * nKeys
	offsetSize := BTREE_OFFSET_SIZE * nKeys
	lenSize := BTREE_KEY_LEN_SIZE*nKeys + BTREE_VALUE_LEN_SIZE*nKeys

	fixed := BTREE_NODE_HEADER_SIZE + ptrSize + offsetSize + lenSize

	// This is avaialble space for values
	_available := int(size) - fixed - len(key)
	assert(_available >= 0, "size is too small")
	available := float64(_available)

	// calculate the size of each value
	valueSizes := make([]uint, nKeys)
	total := uint(len(key))
	for i, p := range kvProp {
		valueSizes[i] = uint(math.Floor((float64(p) / float64(total)) * available))
	}

	node := BtreeNode{data: make([]byte, size)}
	node.setHeader(BTREE_LEAF_NODE, uint16(nKeys))
	for i, k := range key {
		v := slices.Repeat([]byte{k}, int(valueSizes[i]))
		nodeWriteAt(node, uint16(i), 0, []byte{k}, v)
	}
	assert(node.Size()-uint16(size) < node.getNkeys(), "size is too small")
	return node
}

var (
	nodeTemplStr = `type: {{.Type}} nkeys: {{.NKeys}} pointer: {{range $ptr := .Pointers}}` +
		`{{printf "%04x" $ptr}} {{end}} size: {{.Size}}B` +
		`{{ range $kv := .KVs}}` +
		"\n| {{$kv.Key}} ({{$kv.KeyLen}}B) | {{$kv.Value}} ({{$kv.ValueLen}}B) |{{end}}\n"
	nodeTempl = template.Must(template.New("node").Parse(nodeTemplStr))
)

type NodeInfo struct {
	Size     uint16
	Type     string
	NKeys    uint16
	Pointers []uint64
	KVs      []KVInfo
}

type KVInfo struct {
	KeyLen   uint16
	Key      string
	ValueLen uint16
	Value    string
}

var nodeTypeStr = map[uint16]string{
	BTREE_LEAF_NODE:     "LEAF",
	BTREE_INTERNAL_NODE: "INTERNAL",
}

func debugNode(w io.Writer, node BtreeNode) error {
	nodeInfo := NodeInfo{
		Size:     node.Size(),
		Type:     nodeTypeStr[node.getNodeType()],
		NKeys:    node.getNkeys(),
		Pointers: make([]uint64, node.getNkeys()),
		KVs:      make([]KVInfo, node.getNkeys()),
	}

	for i := uint16(0); i < node.getNkeys(); i++ {
		nodeInfo.Pointers[i] = node.getPointer(i)
		key := node.getKey(i)
		value := node.getValue(i)
		nodeInfo.KVs[i] = KVInfo{
			KeyLen:   uint16(len(key)),
			Key:      truncate(string(key), 10),
			ValueLen: uint16(len(value)),
			Value:    truncate(string(value), 10),
		}
	}

	return nodeTempl.Execute(w, nodeInfo)

}

func debugNodeStr(node BtreeNode) string {
	var buf bytes.Buffer
	debugNode(&buf, node)
	return buf.String()
}

type buildLeafNodeConfig struct {
	// The mode used for key-value size specification
	// The valid mode are:  ratio, byte
	mode string
	kvs  []struct {
		key byte
		// The interpretation of size depends on mode
		size uint
	}
	// size is the size of the leaf node. It id used in ratio mode
	size uint
}

type buildNodeOpt func(*buildLeafNodeConfig)

func WithKV(key byte, size uint) buildNodeOpt {
	return func(config *buildLeafNodeConfig) {
		config.kvs = append(config.kvs, struct {
			key  byte
			size uint
		}{
			key,
			size,
		})
	}
}

func WithSize(size uint) buildNodeOpt {
	return func(config *buildLeafNodeConfig) {
		config.size = size
	}
}

// buildLeafNode creates a leaf node of the specified size in bytes.
// Each key is a single byte from key, and len(key) determines the number of KV pairs.
// kvProp defines the relative sizes of values, distributing available space proportionally.
// The value for each key is generated by repeating the key byte to fill its allocated size.
func buildLeafNodeV2(mode string, opts ...buildNodeOpt) BtreeNode {
	config := buildLeafNodeConfig{mode: mode}
	for _, opt := range opts {
		opt(&config)
	}
	// check that kvProp adds up to nKeys

	nKeys := len(config.kvs)
	ptrSize := BTREE_POINTER_SIZE * nKeys
	offsetSize := BTREE_OFFSET_SIZE * nKeys
	lenSize := BTREE_KEY_LEN_SIZE*nKeys + BTREE_VALUE_LEN_SIZE*nKeys

	fixed := BTREE_NODE_HEADER_SIZE + ptrSize + offsetSize + lenSize + nKeys

	valueSizes := make([]uint, nKeys)
	var size uint
	switch config.mode {
	case "ratio":
		// This is avaialble space for values
		_available := int(config.size) - (fixed)

		assert(_available > 0, "size is too small")
		available := float64(_available)

		// calculate the size of each value
		total := 0
		for _, kv := range config.kvs {
			total += int(kv.size)
		}
		for i, kv := range config.kvs {
			valueSizes[i] = uint(math.Floor((float64(kv.size)/float64(total))*available)) - 1
		}
		size = config.size
	case "byte":
		size = uint(fixed)
		for i, kv := range config.kvs {
			size += kv.size
			valueSizes[i] = kv.size - 1
			assert(valueSizes[i] >= 0, "size cannot be at least one")
		}
	default:
		panic("Bad mode")
	}

	node := BtreeNode{data: make([]byte, size)}
	node.setHeader(BTREE_LEAF_NODE, uint16(nKeys))
	for i, kv := range config.kvs {
		v := slices.Repeat([]byte{kv.key}, int(valueSizes[i]))
		nodeWriteAt(node, uint16(i), 0, []byte{kv.key}, v)
	}
	// assert(node.Size()-uint16(size) < node.getNkeys(), "size is too small")
	return node
}

func assertNodeEqual(t *testing.T, expected, actual BtreeNode) {
	if !bytes.Equal(expected.data[:expected.Size()], actual.data[:actual.Size()]) {
		testAssert.Fail(t, "expected: %s\nactual: %s", debugNodeStr(expected), debugNodeStr(actual))
	}
}

// maxKVSize calculate the maxmum size for each KV can have given a node has nKeys where each KV have the same size
func maxKVSize(nKeys uint) uint {
	ptrSize := BTREE_POINTER_SIZE * nKeys
	offsetSize := BTREE_OFFSET_SIZE * nKeys
	lenSize := BTREE_KEY_LEN_SIZE*nKeys + BTREE_VALUE_LEN_SIZE*nKeys
	fixed := BTREE_NODE_HEADER_SIZE + ptrSize + offsetSize + lenSize + nKeys
	return uint(math.Floor(float64(PageSize-int(fixed)) / float64(nKeys)))
}

//
// func Test_nodeSplit(t *testing.T) {
// 	testCases := []struct {
// 		input  BtreeNode
// 		nSplit uint16
// 		splits [3]BtreeNode
// 	}{
// 		// no split
// 		{
// 			input:  buildLeafNodeV2("byte", WithKV(byte('a'), maxKVSize(4))),
// 			nSplit: 1,
// 			splits: [3]BtreeNode{buildLeafNodeV2("byte", WithKV(byte('a'), maxKVSize(4)))},
// 		},
// 		// 3-way split
// 		{
// 			input: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(4)),
// 				WithKV(byte('b'), maxKVSize(1)),
// 				WithKV(byte('c'), maxKVSize(4)),
// 			),
// 			nSplit: 3,
// 			splits: [3]BtreeNode{
// 				buildLeafNodeV2("byte", WithKV(byte('a'), maxKVSize(4))),
// 				buildLeafNodeV2("byte", WithKV(byte('b'), maxKVSize(1))),
// 				buildLeafNodeV2("byte", WithKV(byte('c'), maxKVSize(4))),
// 			},
// 		},
// 		// 2-way split
// 		{
//
// 			input: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(1)),
// 				WithKV(byte('b'), maxKVSize(1)),
// 			),
// 			nSplit: 2,
// 			splits: [3]BtreeNode{
// 				buildLeafNodeV2("byte", WithKV(byte('a'), maxKVSize(1))),
// 				buildLeafNodeV2("byte", WithKV(byte('b'), maxKVSize(1))),
// 			},
// 		},
// 		{
// 			input: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(2)),
// 				WithKV(byte('b'), maxKVSize(2)),
// 				WithKV(byte('c'), maxKVSize(2)),
// 			),
// 			nSplit: 2,
// 			splits: [3]BtreeNode{
// 				buildLeafNodeV2("byte", WithKV(byte('a'), maxKVSize(2))),
// 				buildLeafNodeV2("byte", WithKV(byte('b'), maxKVSize(2)),
// 					WithKV(byte('c'), maxKVSize(2)),
// 				),
// 			},
// 		},
// 	}
//
// 	for i, tc := range testCases {
// 		t.Run(fmt.Sprintf("testcase_%d", i), func(t *testing.T) {
// 			nSplit, splits := nodeSplit(tc.input)
// 			require.Equal(t, tc.nSplit, nSplit)
// 			for i, expected := range tc.splits[:tc.nSplit] {
// 				assertNodeEqual(t, expected, splits[i])
// 			}
//
// 		})
// 	}
//
// }
//
// func Test_nodeLeftRightSplit(t *testing.T) {
// 	testCases := []struct {
// 		input BtreeNode
// 		left  BtreeNode
// 		right BtreeNode
// 	}{
// 		{
// 			input: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(4)),
// 				WithKV(byte('b'), maxKVSize(1)),
// 				WithKV(byte('c'), maxKVSize(4))),
// 			left: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(4)),
// 				WithKV(byte('b'), maxKVSize(1))),
// 			right: buildLeafNodeV2("byte",
// 				WithKV(byte('c'), maxKVSize(4))),
// 		},
// 		{
// 			input: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(2)),
// 				WithKV(byte('b'), maxKVSize(2)),
// 				WithKV(byte('c'), maxKVSize(2))),
// 			left: buildLeafNodeV2("byte",
// 				WithKV(byte('a'), maxKVSize(2))),
// 			right: buildLeafNodeV2("byte",
// 				WithKV(byte('b'), maxKVSize(2)),
// 				WithKV(byte('c'), maxKVSize(2))),
// 		},
// 	}
//
// 	for i, tc := range testCases {
// 		t.Run(fmt.Sprintf("testcase_%d", i+1), func(t *testing.T) {
// 			left := newBtreeNodeWithPageSize(2)
// 			right := newBtreeNodeWithPageSize(2)
// 			nodeLeftRightSplit(left, right, tc.input)
//
// 			assertNodeEqual(t, tc.left, left)
// 			assertNodeEqual(t, tc.right, right)
//
// 		})
// 	}
//
// }
//
// func Test_updateChild(t *testing.T) {
// 	testCases := []struct {
// 		exitingChildren []BtreeNode
// 		newChildren     []BtreeNode
// 		startIdx        uint16
// 		endIdx          uint16
// 		expected        []BtreeNode
// 	}{
// 		// when the len(children) > end - start: when merging
// 		{
// 			exitingChildren: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('b')}, []uint{1}),
// 			},
// 			newChildren: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('c')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('d')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('e')}, []uint{1}),
// 			},
// 			startIdx: 0,
// 			endIdx:   1,
// 			expected: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('c')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('d')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('e')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('b')}, []uint{1}),
// 			},
// 		},
// 		// when the len(children) < end - start: when shrinking
// 		{
// 			exitingChildren: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('b')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('c')}, []uint{1}),
// 			},
// 			newChildren: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('d')}, []uint{1}),
// 			},
// 			startIdx: 1,
// 			endIdx:   3,
// 			expected: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('d')}, []uint{1}),
// 			},
// 		},
// 		// when the len(children) == end - start: replacing children
// 		{
// 			exitingChildren: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('a')}, []uint{1}),
// 			},
// 			newChildren: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('b')}, []uint{1}),
// 			},
// 			expected: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/8, []byte{byte('b')}, []uint{1}),
// 			},
// 			startIdx: 0,
// 			endIdx:   1,
// 		},
// 	}
//
// 	for i, tc := range testCases {
// 		t.Run(fmt.Sprintf("testcase_%d", i+1), func(t *testing.T) {
// 			tree := NewBtreeWithPageAllocator(NewMemPageAllocator())
// 			node := newBtreeNode()
// 			node.setHeader(BTREE_INTERNAL_NODE, uint16(len(tc.exitingChildren)))
// 			assert(node.getNkeys() == uint16(len(tc.exitingChildren)), "old node nKeys != len(existingChildren)")
// 			for i := uint16(0); i < node.getNkeys(); i++ {
// 				nodeWriteAt(node, uint16(i), tree.alloc(tc.exitingChildren[i]), nil, nil)
// 			}
// 			updatedNode := newBtreeNode()
//
// 			updateChildren(tree, updatedNode, node, tc.startIdx, tc.endIdx, tc.newChildren...)
// 			testAssert.Equal(t, uint16(len(tc.expected)), updatedNode.getNkeys())
// 			// assert that [0, start) pointers remain unchanged
// 			for i := uint16(0); i < tc.startIdx; i++ {
// 				testAssert.Equal(t, node.getPointer(i), updatedNode.getPointer(i))
// 			}
//
// 			// assert that [endIdx, nKeys) pointers remain unchanged
// 			for i := uint16(0); i < node.getNkeys()-tc.endIdx; i++ {
// 				oldPtr := node.getPointer(tc.endIdx + i)
// 				newPtr := updatedNode.getPointer(tc.endIdx + (uint16(len(tc.newChildren)) - (tc.endIdx - tc.startIdx)))
// 				testAssert.Equal(t, oldPtr, newPtr)
// 			}
//
// 			for i := uint16(0); i < uint16(len(tc.newChildren)); i++ {
// 				ptr := updatedNode.getPointer(tc.startIdx + i)
// 				child := tree.fetch(ptr)
// 				testAssert.Equal(t, tc.newChildren[i], child)
// 			}
// 		})
// 	}
// }
//
// func Test_mergeNode(t *testing.T) {
// 	testCases := []struct {
// 		left   BtreeNode
// 		right  BtreeNode
// 		merged BtreeNode
// 	}{
// 		{
// 			left: newLeafNodeFromMap(map[string]string{
// 				"a": "1",
// 				"b": "2",
// 			}),
// 			right: newLeafNodeFromMap(map[string]string{}),
// 			merged: newLeafNodeFromMap(map[string]string{
// 				"a": "1",
// 				"b": "2",
// 			}),
// 		},
// 		{
// 			left: newLeafNodeFromMap(map[string]string{}),
// 			right: newLeafNodeFromMap(map[string]string{
// 				"a": "1",
// 				"b": "2",
// 			}),
// 			merged: newLeafNodeFromMap(map[string]string{
// 				"a": "1",
// 				"b": "2",
// 			}),
// 		},
// 		{
// 			left: newLeafNodeFromMap(map[string]string{
// 				"a": "1",
// 				"b": "2",
// 			}),
// 			right: newLeafNodeFromMap(map[string]string{
// 				"c": "3",
// 				"d": "4",
// 			}),
// 			merged: newLeafNodeFromMap(map[string]string{
// 				"a": "1",
// 				"b": "2",
// 				"c": "3",
// 				"d": "4",
// 			}),
// 		},
// 	}
//
// 	for i, tc := range testCases {
// 		t.Run(fmt.Sprintf("testcase_%d", i), func(t *testing.T) {
// 			merged := newBtreeNode()
// 			mergeNode(merged, tc.left, tc.right)
// 			testAssert.Equal(t, tc.merged.data, merged.data)
// 		})
// 	}
// }
//
// func Test_shouldMerge(t *testing.T) {
//
// 	testCases := []struct {
// 		childrens          []BtreeNode
// 		idx                uint16
// 		expectedMergeOpt   mergeOption
// 		expectedSiblingIdx uint16
// 	}{
// 		// smaller than 1/4 but has no slibings
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/5, []byte{byte('a')}, []uint{1}),
// 			},
// 			idx:              0,
// 			expectedMergeOpt: mergeNone,
// 		},
// 		// larger than or equal to 1/4 page
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize), []byte{byte('a')}, []uint{1}),
// 			},
// 			idx:              0,
// 			expectedMergeOpt: mergeNone,
// 		},
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/4, []byte{byte('a')}, []uint{1}),
// 			},
// 			idx:              0,
// 			expectedMergeOpt: mergeNone,
// 		},
// 		// page smaller than 1/4 have mergable left
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/4, []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/5, []byte{byte('b')}, []uint{1}),
// 			},
// 			idx:                1,
// 			expectedMergeOpt:   mergeLeft,
// 			expectedSiblingIdx: 0,
// 		},
// 		// page smaller than 1/4 have mergable right
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/5, []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/4, []byte{byte('b')}, []uint{1}),
// 			},
// 			idx:                0,
// 			expectedMergeOpt:   mergeRight,
// 			expectedSiblingIdx: 1,
// 		},
// 		// page smaller than 1/4 have both mergable
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize)/4, []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/5, []byte{byte('b')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/4, []byte{byte('c')}, []uint{1}),
// 			},
// 			idx:                1,
// 			expectedMergeOpt:   mergeLeft,
// 			expectedSiblingIdx: 0,
// 		},
// 		// two siblings only one if mergable
// 		{
// 			childrens: []BtreeNode{
// 				buildLeafNode(uint(PageSize), []byte{byte('a')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/5, []byte{byte('b')}, []uint{1}),
// 				buildLeafNode(uint(PageSize)/4, []byte{byte('c')}, []uint{1}),
// 			},
// 			idx:                1,
// 			expectedMergeOpt:   mergeRight,
// 			expectedSiblingIdx: 2,
// 		},
// 	}
//
// 	for i, tc := range testCases {
// 		t.Run(fmt.Sprintf("testcase_%d", i), func(t *testing.T) {
// 			tree := NewBtreeWithPageAllocator(NewMemPageAllocator())
// 			node := newBtreeNode()
// 			node.setHeader(BTREE_INTERNAL_NODE, uint16(len(tc.childrens)))
// 			for i, child := range tc.childrens {
// 				ptr := tree.alloc(child)
// 				nodeWriteAt(node, uint16(i), ptr, nil, nil)
// 			}
// 			mergeOpt, sibling := shouldMerge(tree, node, tc.idx, tc.childrens[tc.idx])
// 			testAssert.Equal(t, tc.expectedMergeOpt, mergeOpt)
// 			if tc.expectedMergeOpt != mergeNone {
// 				testAssert.NotNil(t, sibling)
// 			} else {
// 				testAssert.Nil(t, sibling)
// 			}
//
// 		})
// 	}
//
// }

func Test_leafDeleteKV(t *testing.T) {
	testcaeses := []struct {
		input    map[string]string
		index    uint16
		expected map[string]string
	}{
		{
			input: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
			index: 1,
			expected: map[string]string{
				"a": "1",
				"c": "3",
			},
		},
		{
			input: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
			index: 0,
			expected: map[string]string{
				"b": "2",
				"c": "3",
			},
		},
		{
			input: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
			index: 2,
			expected: map[string]string{
				"a": "1",
				"b": "2",
			},
		},
		{
			input: map[string]string{
				"a": "1",
			},
			index:    0,
			expected: map[string]string{},
		},
	}

	for i, tc := range testcaeses {
		t.Run(fmt.Sprintf("testcase_%d", i+1), func(t *testing.T) {
			node := newLeafNodeFromMap(tc.input)
			expected := newLeafNodeFromMap(tc.expected)
			new := newBtreeNode()
			leafDeleteKV(new, node, tc.index)
			testAssert.Equal(t, expected.data, new.data)
		})
	}
}

func Test_leafInsertKV(t *testing.T) {
	testCases := []struct {
		input    map[string]string
		key      string
		value    string
		index    uint16
		expected map[string]string
	}{
		{
			input: map[string]string{
				"a": "1",
				"b": "2",
			},
			key:   "c",
			value: "3",
			index: 2,
			expected: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
		},
		{
			input: map[string]string{
				"a": "1",
				"c": "3",
			},
			key:   "b",
			value: "2",
			index: 1,
			expected: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
		},
		{
			input: map[string]string{
				"b": "2",
				"c": "3",
			},
			key:   "a",
			value: "1",
			index: 0,
			expected: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
		},
	}

	for i, tc := range testCases {
		t.Run(fmt.Sprintf("testcase_%d", i+1), func(t *testing.T) {
			node := newLeafNodeFromMap(tc.input)
			expected := newLeafNodeFromMap(tc.expected)
			new := newBtreeNode()
			leafInsertKV(new, node, tc.index, []byte(tc.key), []byte(tc.value))
			testAssert.Equal(t, expected.data, new.data)
		})
	}
}

func Test_leafUpdateKV(t *testing.T) {
	testCases := []struct {
		input    map[string]string
		key      string
		value    string
		index    uint16
		expected map[string]string
	}{
		{
			input: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
			key:   "b",
			value: "3",
			index: 1,
			expected: map[string]string{
				"a": "1",
				"b": "3",
				"c": "3",
			},
		},
		{
			input: map[string]string{
				"a": "1",
				"b": "2",
				"c": "3",
			},
			key:   "a",
			value: "5",
			index: 0,
			expected: map[string]string{
				"a": "5",
				"b": "2",
				"c": "3",
			},
		},
	}

	for i, tc := range testCases {
		t.Run(fmt.Sprintf("testcase_%d", i+1), func(t *testing.T) {
			node := newLeafNodeFromMap(tc.input)
			expected := newLeafNodeFromMap(tc.expected)
			new := newBtreeNode()
			leafUpdateKV(new, node, tc.index, []byte(tc.key), []byte(tc.value))
			testAssert.Equal(t, expected.data, new.data)
		})
	}
}
